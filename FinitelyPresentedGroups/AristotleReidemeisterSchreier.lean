/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 268012b1-efff-468b-9e5e-eb1a73af4fd4
-/

/-
We defined the Reidemeister-Schreier method, proved that the kernel of the Schreier evaluation map is the normal closure of the extended Schreier relations, constructed a finite presentation for the subgroup, and proved the Reidemeister-Schreier theorem.
-/

import Mathlib


variable (G : Type*) [Group G] (ι : Type w)

structure Generators where
  /-- The assignment of each variable to a value in `G`. -/
  val : ι → G
  gen : Subgroup.closure (Set.range val) = ⊤

structure Presentation extends Generators G ι where
  /-- The relations on the generators. -/
  rels : Set (FreeGroup ι)
  /-- The normal closure of `rels` is the kernel of the induced map. -/
  ker_eq : MonoidHom.ker (FreeGroup.lift val) = Subgroup.normalClosure rels

structure FinitePresentation' (ι : Type*) [Fintype ι] extends Presentation G ι where
  h_fin : Finite rels

structure FinitePresentation (ι : Type*) [Fintype ι] extends Generators G ι where
  /-- The relations on the generators. -/
  rels : Finset (FreeGroup ι)
  /-- The normal closure of `rels` is the kernel of the induced map. -/
  ker_eq : MonoidHom.ker (FreeGroup.lift val) = Subgroup.normalClosure rels

def expe (ι : Type*) [Fintype ι] : FinitePresentation G ι → Presentation G ι :=
  fun P ↦
    { val := P.val
      gen := P.gen
      rels := P.rels.toSet
      ker_eq := P.ker_eq }

def isFinitelyPresented' : Prop :=
  ∃ (ι : Type*) (_ : Fintype ι) (g : Presentation G ι), Finite g.rels

variable (α : Type*)

def presZ : Presentation (Multiplicative ℤ) (Fin 1) :=
  { val := fun _ ↦ Multiplicative.ofAdd 1
    gen := by
      simp ( config := { decide := Bool.true } ) [ Subgroup.eq_top_iff' ];
      intro a;
      induction a using Int.induction_on <;> aesop
    rels := ∅
    ker_eq := by
      ext;
      aesop
      generalize_proofs at *;
      · -- Since the free group on one generator is isomorphic to the integers, any element x can be written as a power of the generator.
        have h_iso : ∀ x : FreeGroup (Fin 1), ∃ n : ℤ, x = FreeGroup.of 0 ^ n := by
          intro x
          induction' x using FreeGroup.induction_on with x ih;
          · exact ⟨ 0, by simp +decide ⟩;
          · exact ⟨ 1, by fin_cases x; simp +decide ⟩;
          · rcases ‹_› with ⟨ n, hn ⟩ ; exact ⟨ -n, by rw [ hn, zpow_neg ] ⟩;
          · aesop;
            exact ⟨ w + w_1, by rw [ zpow_add ] ⟩;
        -- Since the lift of x is 1, n must be zero. Therefore, x is the identity element.
        obtain ⟨n, hn⟩ := h_iso x
        have hn_zero : n = 0 := by
          replace a := congr_arg Multiplicative.toAdd a ; aesop;
        aesop;
      · simp_all +decide [ Subgroup.normalClosure ];
        simp_all +decide [ Subgroup.closure, Group.conjugatesOfSet ]}

#check isFinitelyPresented'
#check Subgroup.FiniteIndex

/-
The statement of the Reidemeister-Schreier theorem as a Prop, with explicit universe levels.
-/
universe u v

def ReidemeisterSchreierStatement : Prop :=
  ∀ {G : Type u} [Group G] (H : Subgroup G) [H.FiniteIndex],
    isFinitelyPresented'.{u, v} G → isFinitelyPresented'.{u, v} H

/-
The index set for the Schreier generators is the product of the set of cosets G/H and the set of generators of G.
-/
def SchreierIndex {G : Type*} [Group G] {ι : Type*} (H : Subgroup G) := (G ⧸ H) × ι

/-
Definition of a transversal `τ` mapping cosets to representatives, with `τ(H) = 1`.
-/
open Classical

noncomputable def τ {G : Type*} [Group G] (H : Subgroup G) (q : G ⧸ H) : G :=
  if q = QuotientGroup.mk 1 then 1 else Quotient.out q

theorem τ_one {G : Type*} [Group G] (H : Subgroup G) : τ H (QuotientGroup.mk 1) = 1 := by
  unfold τ;
  simp +decide [ QuotientGroup.eq ]

theorem τ_spec {G : Type*} [Group G] (H : Subgroup G) (q : G ⧸ H) : QuotientGroup.mk (τ H q) = q := by
  rw [ τ ];
  aesop

/-
Definition of the Schreier generator `schreier_gen` and proof that it belongs to `H`.
-/
noncomputable def schreier_gen {G : Type*} [Group G] {ι : Type*} (P : Presentation G ι) (H : Subgroup G) (k : G ⧸ H) (s : ι) : G :=
  let t := τ H k
  let x := P.val s
  (τ H (QuotientGroup.mk (t * x)))⁻¹ * (t * x)

theorem schreier_gen_mem {G : Type*} [Group G] {ι : Type*} (P : Presentation G ι) (H : Subgroup G) (k : G ⧸ H) (s : ι) :
    schreier_gen P H k s ∈ H := by
      have := QuotientGroup.eq.1 ( τ_spec H ( τ H k * P.val s ) ) ; aesop

/-
Checking the type of QuotientGroup.mk.
-/
#check QuotientGroup.mk

/-
Definition of standard Schreier generators.
-/
noncomputable def schreier_gen_std {G : Type*} [Group G] {ι : Type*} (P : Presentation G ι) (H : Subgroup G) (k : G ⧸ H) (s : ι) : G :=
  let t := τ H k
  let x := P.val s
  t * x * (τ H (QuotientGroup.mk (t * x)))⁻¹

/-
Checking if schreier_gen and schreier_gen_mem are available.
-/
#check schreier_gen
#check schreier_gen_mem

/-
Checking for the existence of QuotientGroup.rightRel.
-/
#check QuotientGroup.rightRel

/-
Definitions for right cosets, their action, and a transversal.
-/
def RightCosets {G : Type*} [Group G] (H : Subgroup G) := Quotient (QuotientGroup.rightRel H)

instance {G : Type*} [Group G] (H : Subgroup G) : Inhabited (RightCosets H) :=
  ⟨Quotient.mk _ 1⟩

def RightCosets.act {G : Type*} [Group G] {H : Subgroup G} (k : RightCosets H) (g : G) : RightCosets H :=
  k.liftOn (fun x ↦ Quotient.mk _ (x * g)) <| by
    simp ( config := { decide := Bool.true } ) [ Setoid.ext_iff ];
    -- By definition of right cosets, if $a \approx b$, then $a * g \approx b * g$ for any $g \in G$.
    intros a b hab
    obtain ⟨h, hh⟩ := hab;
    -- Since $h \in H$, we have $h * (b * g) = (h * b) * g = a * g$.
    have h_coset_eq : h * (b * g) = a * g := by
      aesop;
      rw [ mul_assoc ];
    -- Since $h \in H$, we have $h * (b * g) = a * g$, thus $⟦a * g⟧ = ⟦b * g⟧$.
    apply Eq.symm; exact (by
    apply Quotient.eq.mpr;
    simp ( config := { decide := Bool.true } ) [ ← h_coset_eq, QuotientGroup.rightRel_apply ];
    simp ( config := { decide := Bool.true } ) [ mul_assoc, h.2 ])

noncomputable def τ_right {G : Type*} [Group G] (H : Subgroup G) (k : RightCosets H) : G :=
  if k = Quotient.mk _ 1 then 1 else k.out

theorem τ_right_spec {G : Type*} [Group G] (H : Subgroup G) (k : RightCosets H) :
    Quotient.mk (QuotientGroup.rightRel H) (τ_right H k) = k := by
      -- By definition of τ_right, we have τ_right H k = Quotient.out k.
      simp [τ_right];
      -- By definition of Quotient.out, we have ⟦Quotient.out k⟧ = k.
      cases' eq_or_ne k ⟦1⟧ with hk hk <;> simp [hk]

/-
The index set for the Schreier generators using right cosets.
-/
def SchreierIndexRight {G : Type*} [Group G] {ι : Type*} (H : Subgroup G) := (RightCosets H) × ι

/-
Definition of Schreier generators for right cosets and proof of membership in H.
-/
noncomputable def schreier_gen_right {G : Type*} [Group G] {ι : Type*} (P : Presentation G ι) (H : Subgroup G) (k : RightCosets H) (s : ι) : G :=
  let t := τ_right H k
  let x := P.val s
  t * x * (τ_right H (k.act x))⁻¹

theorem schreier_gen_right_mem {G : Type*} [Group G] {ι : Type*} (P : Presentation G ι) (H : Subgroup G) (k : RightCosets H) (s : ι) :
    schreier_gen_right P H k s ∈ H := by
      have := τ_right_spec H k
      generalize_proofs at *;
      unfold schreier_gen_right;
      field_simp;
      rw [ show k.act ( P.val s ) = Quotient.mk _ ( τ_right H k * P.val s ) by
            rw [ ← this ];
            simp ( config := { decide := Bool.true } ) [ RightCosets.act ];
            rw [ this ] ];
      have := τ_right_spec H ⟦τ_right H k * P.val s⟧;
      rw [ Quotient.eq ] at this;
      rw [ QuotientGroup.rightRel_eq ] at this;
      exact this

/-
Definition of the rewriting process for a word using right cosets, avoiding type aliases.
-/
noncomputable def rewrite_word_right {G : Type*} [Group G] {ι : Type*} (P : Presentation G ι) (H : Subgroup G)
    (k : RightCosets H) (w : List (ι × Bool)) : FreeGroup ((RightCosets H) × ι) :=
  match w with
  | [] => 1
  | (s, true) :: t =>
      let next_k := k.act (P.val s)
      FreeGroup.of (k, s) * rewrite_word_right P H next_k t
  | (s, false) :: t =>
      let next_k := k.act (P.val s)⁻¹
      (FreeGroup.of (next_k, s))⁻¹ * rewrite_word_right P H next_k t

/-
Definition of coset_word and proof of its property using surjectivity.
-/
theorem lift_surjective {G : Type*} [Group G] {ι : Type*} (P : Presentation G ι) :
    Function.Surjective (FreeGroup.lift P.val) := by
      -- By definition of `P`, the generators `val` span `G`.
      have h_span : Subgroup.closure (Set.range P.val) = ⊤ := by
        exact P.gen;
      rw [ SetLike.ext_iff ] at h_span;
      intro x; specialize h_span x; simp_all +decide [ Subgroup.mem_closure ] ;
      specialize h_span ( Subgroup.map ( FreeGroup.lift P.val ) ⊤ ) ; simp_all +decide [ Set.range_subset_iff ];
      exact h_span fun y => ⟨ FreeGroup.of y, by simp +decide ⟩

noncomputable def coset_word {G : Type*} [Group G] {ι : Type*} (P : Presentation G ι) (H : Subgroup G) (k : RightCosets H) : FreeGroup ι :=
  Classical.choose (lift_surjective P (τ_right H k))

theorem coset_word_spec {G : Type*} [Group G] {ι : Type*} (P : Presentation G ι) (H : Subgroup G) (k : RightCosets H) :
    FreeGroup.lift P.val (coset_word P H k) = τ_right H k := by
      -- Since the free group on the empty type is trivial, the only element in the free group is the identity.
      have h_trivial : ∀ (f : FreeGroup Unit →* G), f 1 = 1 := by
        exact fun f => f.map_one;
      unfold coset_word; aesop;
      all_goals generalize_proofs at *;
      exact Classical.choose_spec ‹∃ x, ( FreeGroup.lift P.val ) x = τ_right H k›

/-
Checking for MonoidHom.range_eq_top.
-/
#check MonoidHom.range_eq_top

/-
The rewriting process respects single reduction steps.
-/
theorem rewrite_word_right_respects_step {G : Type*} [Group G] {ι : Type*} (P : Presentation G ι) (H : Subgroup G)
    (k : RightCosets H) (w1 w2 : List (ι × Bool)) (h : FreeGroup.Red.Step w1 w2) :
    rewrite_word_right P H k w1 = rewrite_word_right P H k w2 := by
  induction h;
  rename_i L₁ L₂ x b;
  induction L₁ generalizing k <;> aesop;
  · cases b <;> simp ( config := { decide := Bool.true } ) [ rewrite_word_right ];
    · -- By definition of `act`, we have `k.act (P.val x)⁻¹ = k * (P.val x)⁻¹`.
      have h_act_inv : ∀ (k : RightCosets H) (x : G), (k.act x⁻¹).act x = k := by
        unfold RightCosets.act; aesop;
        induction k_1 using Quotient.inductionOn' ; aesop;
      rw [ h_act_inv ];
    · unfold RightCosets.act;
      induction' k using Quotient.inductionOn' with k ih;
      induction' L₂ with L₂ ih generalizing k <;> aesop;
  · unfold rewrite_word_right; aesop;

/-
Definition of the rewriting process on the free group.
-/
noncomputable def rewrite {G : Type*} [Group G] {ι : Type*} (P : Presentation G ι) (H : Subgroup G)
    (k : RightCosets H) (w : FreeGroup ι) : FreeGroup ((RightCosets H) × ι) :=
  Quot.lift (fun l ↦ rewrite_word_right P H k l) (fun l1 l2 h ↦ rewrite_word_right_respects_step P H k l1 l2 h) w

/-
Definition of the relations for the subgroup presentation, with explicit type arguments.
-/
def rels_H {G : Type*} [Group G] {ι : Type*} (P : Presentation G ι) (H : Subgroup G) : Set (FreeGroup (@SchreierIndexRight G _ ι H)) :=
  (⋃ k : RightCosets H, (rewrite P H k) '' P.rels) ∪
  { w | ∃ (k : RightCosets H) (s : ι), schreier_gen_right P H k s = 1 ∧ w = FreeGroup.of (k, s) }

/-
Valuation function for the Schreier generators.
-/
def schreier_val {G : Type*} [Group G] {ι : Type*} (P : Presentation G ι) (H : Subgroup G) : (@SchreierIndexRight G _ ι H) → H :=
  fun ⟨k, s⟩ ↦ ⟨schreier_gen_right P H k s, schreier_gen_right_mem P H k s⟩

/-
The rewriting process satisfies a cocycle-like property on products.
-/
theorem rewrite_mul {G : Type*} [Group G] {ι : Type*} (P : Presentation G ι) (H : Subgroup G)
    (k : RightCosets H) (w1 w2 : FreeGroup ι) :
    rewrite P H k (w1 * w2) = rewrite P H k w1 * rewrite P H (k.act (FreeGroup.lift P.val w1)) w2 := by
  -- This needs to be proven by induction on w1 (as a list) and then lifted to FreeGroup.
  -- Since `rewrite` is defined via `Quot.lift`, we can use `Quot.inductionOn`.
  induction w1 using Quot.inductionOn
  induction w2 using Quot.inductionOn
  rename_i l1 l2
  -- Now we are dealing with lists.
  -- We need a lemma for lists: rewrite_word_right P H k (l1 ++ l2) = ...
  -- By definition of rewrite, we have:
  have h_rewrite_def : ∀ (k : RightCosets H) (l : List (ι × Bool)), rewrite P H k (Quot.mk FreeGroup.Red.Step l) = rewrite_word_right P H k l := by
    aesop;
  induction' l1 using List.reverseRecOn with l1 ih generalizing k l2 <;> aesop;
  · simp ( config := { decide := Bool.true } ) [ rewrite_word_right ];
    -- Since $k.act 1$ is just $k$, we have $rewrite_word_right P H k l2 = rewrite_word_right P H (k.act 1) l2$.
    have h_act_one : k.act 1 = k := by
      exact Quotient.inductionOn' k fun x => by simp ( config := { decide := Bool.true } ) [ RightCosets.act ] ;
    rw [ h_act_one ];
  · -- By definition of rewrite_word_right, we can split the product into the product of the first element and the rest.
    have h_split : ∀ (k : RightCosets H) (s : ι) (l : List (ι × Bool)), rewrite_word_right P H k ((s, snd) :: l) = rewrite_word_right P H k [(s, snd)] * rewrite_word_right P H (k.act (bif snd then P.val s else (P.val s)⁻¹)) l := by
      unfold rewrite_word_right; aesop;
    rw [ h_split, mul_assoc ];
    congr! 3;
    -- By definition of the action, we have:
    simp [RightCosets.act];
    exact Quotient.inductionOn' k fun x => by simp ( config := { decide := Bool.true } ) [ mul_assoc ] ;

/-
The evaluation of the rewritten word relates to the original word via the transversal.
-/
theorem rewrite_eval_eq {G : Type*} [Group G] {ι : Type*} (P : Presentation G ι) (H : Subgroup G)
    (k : RightCosets H) (w : FreeGroup ι) :
    FreeGroup.lift (fun p : (@SchreierIndexRight G _ ι H) ↦ schreier_gen_right P H p.1 p.2) (rewrite P H k w) =
    τ_right H k * (FreeGroup.lift P.val w) * (τ_right H (k.act (FreeGroup.lift P.val w)))⁻¹ := by
  -- Proof by induction on w using Quot.inductionOn and List.induction
  induction w using Quot.inductionOn
  rename_i l
  induction l generalizing k
  case nil =>
    simp [rewrite, rewrite_word_right, τ_right, RightCosets.act]
    -- Need to handle k.act 1 = k and τ_right H k * 1 * (τ_right H k)⁻¹ = 1
    all_goals generalize_proofs at *;
    cases k using Quotient.inductionOn' ; aesop
  case cons head tail ih =>
    cases head
    rename_i s b
    cases b
    case false =>
      -- Case s⁻¹
      simp [rewrite, rewrite_word_right]
      -- Use induction hypothesis
      convert congr_arg ( fun x => ( schreier_gen_right P H ( k.act ( P.val s ) ⁻¹ ) s ) ⁻¹ * x ) ( ih ( k.act ( P.val s ) ⁻¹ ) ) using 1;
      simp +decide [ inv_mul_cancel_left, mul_assoc, schreier_gen_right ];
      congr! 2;
      · -- By definition of right coset action, we have:
        simp [RightCosets.act];
        induction k using Quotient.inductionOn' ; aesop;
      · congr! 2;
        congr! 1;
        unfold RightCosets.act; aesop;
        induction k using Quotient.inductionOn' ; aesop;
        rw [ mul_assoc ]
    case true =>
      -- Case s
      simp [rewrite, rewrite_word_right]
      -- Use induction hypothesis
      convert congr_arg ( fun x => schreier_gen_right P H k s * x ) ( ih ( k.act ( P.val s ) ) ) using 1;
      unfold schreier_gen_right; simp +decide [ mul_assoc ] ;
      -- By definition of `RightCosets.act`, we can rewrite the right-hand side to match the left-hand side.
      simp [RightCosets.act];
      refine' congr_arg _ ( Quotient.inductionOn k _ );
      simp +decide [ Quotient.liftOn, mul_assoc ]

/-
Helper lemma: The evaluation of the rewritten word (as a list) relates to the original word via the transversal.
-/
theorem rewrite_word_right_eval_eq {G : Type*} [Group G] {ι : Type*} (P : Presentation G ι) (H : Subgroup G)
    (k : RightCosets H) (l : List (ι × Bool)) :
    FreeGroup.lift (fun p : (@SchreierIndexRight G _ ι H) ↦ schreier_gen_right P H p.1 p.2) (rewrite_word_right P H k l) =
    τ_right H k * (FreeGroup.lift P.val (FreeGroup.mk l)) * (τ_right H (k.act (FreeGroup.lift P.val (FreeGroup.mk l))))⁻¹ := by
      convert rewrite_eval_eq P H k ( FreeGroup.mk l ) using 1

/-
Helper lemma: The evaluation of the rewritten word (as a list) relates to the original word via the transversal.
-/
theorem rewrite_word_right_eval_eq' {G : Type*} [Group G] {ι : Type*} (P : Presentation G ι) (H : Subgroup G)
    (k : RightCosets H) (l : List (ι × Bool)) :
    FreeGroup.lift (fun p : (@SchreierIndexRight G _ ι H) ↦ schreier_gen_right P H p.1 p.2) (rewrite_word_right P H k l) =
    τ_right H k * (FreeGroup.lift P.val (FreeGroup.mk l)) * (τ_right H (k.act (FreeGroup.lift P.val (FreeGroup.mk l))))⁻¹ := by
      -- Apply the lemma rewrite_word_right_eval_eq directly.
      apply rewrite_word_right_eval_eq

/-
The Schreier generators generate the subgroup H.
-/
theorem H_generators_gen {G : Type*} [Group G] {ι : Type*} (P : Presentation G ι) (H : Subgroup G) :
    Subgroup.closure (Set.range (schreier_val P H)) = ⊤ := by
      -- Let $h \in H$. We need to show that $h$ can be written as a product of the Schreier generators.
      have h_schreier_gen : ∀ h : G, h ∈ H → ∃ l : List (ι × Bool), FreeGroup.lift P.val (FreeGroup.mk l) = h := by
        intro h hh;
        have := P.gen;
        replace this := SetLike.ext_iff.mp this h;
        simp +zetaDelta at *;
        refine' Subgroup.closure_induction _ _ _ _ this;
        · rintro _ ⟨ x, rfl ⟩ ; exact ⟨ [ ( x, Bool.true ) ], by simp +decide ⟩;
        · exact ⟨ [ ], rfl ⟩;
        · rintro x y hx hy ⟨ l₁, rfl ⟩ ⟨ l₂, rfl ⟩ ; exact ⟨ l₁ ++ l₂, by simp +decide ⟩;
        · rintro x hx ⟨ l, rfl ⟩;
          refine' ⟨ l.reverse.map fun x => ( x.1, !x.2 ), _ ⟩ ; simp +decide [ List.prod_inv_reverse ];
          congr;
          ext ⟨ x, b ⟩ ; by_cases hb : b <;> simp +decide [ hb ];
      -- By definition of Schreier generators, every element of $H$ can be written as a product of the Schreier generators.
      have h_schreier_gen_all : ∀ h : G, h ∈ H → ∃ w : FreeGroup ((RightCosets H) × ι), FreeGroup.lift (fun p : (RightCosets H) × ι => schreier_gen_right P H p.1 p.2) w = h := by
        intro h hh
        obtain ⟨l, hl⟩ := h_schreier_gen h hh
        use rewrite P H (Quotient.mk (QuotientGroup.rightRel H) 1) (FreeGroup.mk l);
        have := rewrite_eval_eq P H ( Quotient.mk ( QuotientGroup.rightRel H ) 1 ) ( FreeGroup.mk l ) ; aesop;
        unfold τ_right at * ; aesop;
        contrapose! h;
        erw [ Quotient.eq ] ; aesop;
        simp_all +decide [ QuotientGroup.rightRel_apply ];
      have h_schreier_gen_all : ∀ h : H, ∃ w : FreeGroup ((RightCosets H) × ι), FreeGroup.lift (fun p : (RightCosets H) × ι => ↑(schreier_val P H p)) w = h := by
        simp +zetaDelta at *;
        intro h hh; obtain ⟨ w, hw ⟩ := h_schreier_gen_all h hh; use w; simp +decide [ hw, Subtype.ext_iff ] ;
        convert hw using 1;
        refine' FreeGroup.induction_on w _ _ _ _ <;> aesop;
      refine' eq_top_iff.mpr fun h hh => _;
      obtain ⟨ w, rfl ⟩ := h_schreier_gen_all h;
      refine' FreeGroup.induction_on w _ _ _ _;
      · simp +decide;
      · simp +decide [ Subgroup.mem_closure ];
        exact fun a b K hK => hK ⟨ _, rfl ⟩;
      · simp +decide [ Subgroup.closure ];
      · simp +contextual [ Subgroup.mul_mem_cancel_left, Subgroup.mul_mem_cancel_right ]

def H_generators {G : Type*} [Group G] {ι : Type*} (P : Presentation G ι) (H : Subgroup G) : Generators H (@SchreierIndexRight G _ ι H) :=
  { val := schreier_val P H
    gen := H_generators_gen P H }

/-
The Schreier generators generate the subgroup H (proven).
-/
theorem H_generators_gen_proven {G : Type*} [Group G] {ι : Type*} (P : Presentation G ι) (H : Subgroup G) :
    Subgroup.closure (Set.range (schreier_val P H)) = ⊤ := by
      exact?

/-
The relations of the subgroup presentation are satisfied by the Schreier generators.
-/
theorem H_ker_le {G : Type*} [Group G] {ι : Type*} (P : Presentation G ι) (H : Subgroup G) :
    Subgroup.normalClosure (rels_H P H) ≤ MonoidHom.ker (FreeGroup.lift (schreier_val P H)) := by
      -- To prove the inclusion, it suffices to show that every element in `rels_H P H` is in the kernel of the lift.
      suffices h_relss : ∀ w ∈ rels_H P H, FreeGroup.lift (schreier_val P H) w = 1 by
        -- Apply the fact that if every element of a set is in the kernel of a group homomorphism, then the normal closure of that set is also in the kernel of the homomorphism.
        apply Subgroup.normalClosure_le_normal;
        exact fun w hw => h_relss w hw;
      intro w hw
      simp [rels_H] at hw;
      rcases hw with ( ⟨ k, x, hx, rfl ⟩ | ⟨ k, s, hs, rfl ⟩ );
      · -- By definition of `rewrite`, we know that `rewrite P H k x` is a product of elements in the kernel of the lift.
        have h_rewrite_kernel : FreeGroup.lift (schreier_val P H) (rewrite P H k x) = τ_right H k * (FreeGroup.lift P.val x) * (τ_right H (k.act (FreeGroup.lift P.val x)))⁻¹ := by
          convert rewrite_eval_eq P H k x;
          induction' ( rewrite P H k x ) using FreeGroup.induction_on with x ih;
          · simp +decide [ schreier_val ];
          · exact?;
          · aesop;
          · aesop;
        have h_rewrite_kernel : (FreeGroup.lift P.val x) = 1 := by
          have h_rewrite_kernel : x ∈ MonoidHom.ker (FreeGroup.lift P.val) := by
            exact P.ker_eq.symm ▸ Subgroup.subset_normalClosure hx;
          exact?;
        have h_rewrite_kernel : k.act 1 = k := by
          exact Quotient.inductionOn' k fun g => by simp +decide [ RightCosets.act ] ;
        aesop;
      · convert hs using 1;
        simp +decide [ schreier_val ]

/-
Definition of the section U and the map sigma.
-/
noncomputable def U {G : Type*} [Group G] {ι : Type*} (P : Presentation G ι) (H : Subgroup G) (k : RightCosets H) : FreeGroup ι :=
  coset_word P H k

noncomputable def sigma {G : Type*} [Group G] {ι : Type*} (P : Presentation G ι) (H : Subgroup G) : FreeGroup (@SchreierIndexRight G _ ι H) →* FreeGroup ι :=
  FreeGroup.lift (fun p : (@SchreierIndexRight G _ ι H) ↦ U P H p.1 * FreeGroup.of p.2 * (U P H (p.1.act (P.val p.2)))⁻¹)


/-
The map `sigma` followed by evaluation in `G` is the same as evaluating the Schreier generators in `G`.
-/
theorem sigma_lift_eq {G : Type*} [Group G] {ι : Type*} (P : Presentation G ι) (H : Subgroup G) (w : FreeGroup (@SchreierIndexRight G _ ι H)) :
    FreeGroup.lift P.val (sigma P H w) = FreeGroup.lift (schreier_val P H) w := by
      induction w using FreeGroup.induction_on ; aesop;
      · simp +decide [ sigma, schreier_val ];
        unfold U;
        rw [ coset_word_spec, coset_word_spec ];
        exact?;
      · simp_all +decide [ MonoidHom.coe_comp ];
      · aesop

/-
The rewrite of the identity element is the identity element.
-/
theorem rewrite_one {G : Type*} [Group G] {ι : Type*} (P : Presentation G ι) (H : Subgroup G) (k : RightCosets H) :
    rewrite P H k 1 = 1 := by
      exact?

/-
The rewrite of an inverse is the inverse of the rewrite (with shifted coset).
-/
theorem rewrite_inv {G : Type*} [Group G] {ι : Type*} (P : Presentation G ι) (H : Subgroup G) (k : RightCosets H) (w : FreeGroup ι) :
    rewrite P H (k.act (FreeGroup.lift P.val w)) w⁻¹ = (rewrite P H k w)⁻¹ := by
      have h_rewrite_inv : rewrite P H k (w * w⁻¹) = rewrite P H k w * rewrite P H (k.act (FreeGroup.lift P.val w)) w⁻¹ := by
        exact?;
      have := rewrite_one P H k; aesop;
      exact eq_inv_of_mul_eq_one_right h_rewrite_inv.symm

/-
Stronger version of `rewrite_mem_normalClosure` that holds for any coset `k`.
-/
theorem rewrite_mem_normalClosure_strong {G : Type*} [Group G] {ι : Type*} (P : Presentation G ι) (H : Subgroup G)
    (r : FreeGroup ι) (hr : r ∈ Subgroup.normalClosure P.rels) (k : RightCosets H) :
    rewrite P H k r ∈ Subgroup.normalClosure (rels_H P H) := by
      refine' Subgroup.closure_induction ( fun x hx => _ ) _ _ _ hr;
      · simp_all +decide [ Group.conjugatesOfSet ];
        simp_all +decide [ conjugatesOf ];
        obtain ⟨ i, hi, c, rfl ⟩ := hx;
        -- By definition of rewrite, we have:
        have h_rewrite : rewrite P H k (c * i * c⁻¹) = rewrite P H k c * rewrite P H (k.act (FreeGroup.lift P.val c)) i * (rewrite P H k c)⁻¹ := by
          have h_rewrite : rewrite P H k (c * i * c⁻¹) = rewrite P H k c * rewrite P H (k.act (FreeGroup.lift P.val c)) i * rewrite P H (k.act (FreeGroup.lift P.val (c * i))) c⁻¹ := by
            have h_rewrite : ∀ (w1 w2 : FreeGroup ι), rewrite P H k (w1 * w2) = rewrite P H k w1 * rewrite P H (k.act (FreeGroup.lift P.val w1)) w2 := by
              exact?;
            rw [ h_rewrite, h_rewrite ];
          convert h_rewrite using 2;
          rw [ ← rewrite_inv ];
          have h_rewrite : FreeGroup.lift P.val i = 1 := by
            have h_rewrite : i ∈ MonoidHom.ker (FreeGroup.lift P.val) := by
              exact P.ker_eq.symm ▸ Subgroup.subset_normalClosure hi;
            exact h_rewrite;
          simp +decide [ h_rewrite, MonoidHom.map_mul ];
        -- Since $i \in P.rels$, we have $rewrite P H (k.act (FreeGroup.lift P.val c)) i \in rels_H P H$.
        have h_rewrite_i : rewrite P H (k.act (FreeGroup.lift P.val c)) i ∈ rels_H P H := by
          exact Set.mem_union_left _ ( Set.mem_iUnion.mpr ⟨ _, Set.mem_image_of_mem _ hi ⟩ );
        exact h_rewrite.symm ▸ Subgroup.Normal.mem_comm inferInstance ( by simpa using Subgroup.subset_normalClosure h_rewrite_i );
      · exact OneMemClass.one_mem _;
      · simp +decide [ rewrite_mul ];
        intro x y hx hy hx' hy';
        -- Since $x \in \text{normalClosure}(P.rels)$, we have $FreeGroup.lift P.val x = 1$.
        have hx_lift : FreeGroup.lift P.val x = 1 := by
          have h_conj : x ∈ MonoidHom.ker (FreeGroup.lift P.val) := by
            have h_conj : Subgroup.closure (Group.conjugatesOfSet P.rels) ≤ Subgroup.normalClosure P.rels := by
              bound;
            exact P.ker_eq.symm ▸ h_conj hx;
          exact h_conj;
        simp_all +decide [ Subgroup.mul_mem_cancel_left, Subgroup.mul_mem_cancel_right ];
        convert hy' using 1;
        exact Quotient.inductionOn' k fun g => by simp +decide [ RightCosets.act ] ;
      · intro x hx hx';
        convert Subgroup.inv_mem _ hx' using 1;
        rw [ ← rewrite_inv ];
        rw [ show ( FreeGroup.lift P.val ) x = 1 from _ ];
        · exact Quotient.inductionOn' k fun g => by simp +decide [ RightCosets.act ] ;
        · -- Since $x$ is in the normal closure of $P.rels$, applying the lift of $P.val$ to $x$ gives $1$.
          have h_lift_x : ∀ x ∈ Subgroup.normalClosure P.rels, FreeGroup.lift P.val x = 1 := by
            intro x hx
            have h_lift_x : ∀ r ∈ P.rels, FreeGroup.lift P.val r = 1 := by
              intro r hr
              have h_lift_r : r ∈ MonoidHom.ker (FreeGroup.lift P.val) := by
                exact P.ker_eq.symm ▸ Subgroup.subset_normalClosure hr;
              exact h_lift_r;
            refine' Subgroup.closure_induction ( fun r hr => _ ) _ _ _ hx;
            · rw [ Group.mem_conjugatesOfSet_iff ] at hr;
              aesop;
            · exact map_one _;
            · aesop;
            · simp +contextual;
          exact h_lift_x x ( by rw [ Subgroup.normalClosure ] at *; aesop )

/-
`rewrite_word_right` distributes over list concatenation (multiplication in free group).
-/
theorem rewrite_word_right_append {G : Type*} [Group G] {ι : Type*} (P : Presentation G ι) (H : Subgroup G) (k : RightCosets H) (l1 l2 : List (ι × Bool)) :
    rewrite_word_right P H k (l1 ++ l2) = rewrite_word_right P H k l1 * rewrite_word_right P H (k.act (FreeGroup.lift P.val (FreeGroup.mk l1))) l2 := by
      convert rewrite_word_right_eval_eq' P H k (l1 ++ l2) using 1;
      constructor <;> intro h;
      · convert rewrite_word_right_eval_eq' P H k ( l1 ++ l2 ) using 1;
      · convert rewrite_mul P H k ( FreeGroup.mk l1 ) ( FreeGroup.mk l2 ) using 1

/-
The rewrite of a transversal element evaluates to 1 in the group.
-/
theorem rewrite_U_in_ker {G : Type*} [Group G] {ι : Type*} (P : Presentation G ι) (H : Subgroup G) (k : RightCosets H) :
    FreeGroup.lift (schreier_val P H) (rewrite P H (Quotient.mk _ 1) (U P H k)) = 1 := by
      have h_rewrite_one : ∀ k : RightCosets H, (FreeGroup.lift (schreier_val P H)) (rewrite P H ⟦1⟧ (U P H k)) =
                          1 * (τ_right H k) * (τ_right H k)⁻¹ := by
                            intro k
                            have h_rewrite_one : (FreeGroup.lift (fun p : (@SchreierIndexRight G _ ι H) ↦ schreier_gen_right P H p.1 p.2) (rewrite P H ⟦1⟧ (U P H k))) = 1 * (τ_right H k) * (τ_right H k)⁻¹ := by
                              convert rewrite_eval_eq P H ⟦1⟧ (U P H k) using 1;
                              unfold U;
                              rw [ coset_word_spec ];
                              unfold RightCosets.act;
                              unfold τ_right; aesop;
                            convert h_rewrite_one using 1;
                            induction ( rewrite P H ⟦1⟧ ( U P H k ) ) using FreeGroup.induction_on <;> aesop;
      aesop

/-
The extended relations `rels_H'` are contained in the kernel of the Schreier evaluation map.
-/
def rels_H' {G : Type*} [Group G] {ι : Type*} (P : Presentation G ι) (H : Subgroup G) : Set (FreeGroup (@SchreierIndexRight G _ ι H)) :=
  rels_H P H ∪ (Set.range (fun k : RightCosets H ↦ rewrite P H (Quotient.mk _ 1) (U P H k)))

theorem rels_H'_le_ker {G : Type*} [Group G] {ι : Type*} (P : Presentation G ι) (H : Subgroup G) :
    Subgroup.normalClosure (rels_H' P H) ≤ MonoidHom.ker (FreeGroup.lift (schreier_val P H)) := by
      unfold rels_H';
      refine' Subgroup.normalClosure_le_normal _;
      rintro x ( hx | ⟨ k, rfl ⟩ ) <;> simp_all +decide [ MonoidHom.mem_ker ];
      · -- Since $x \in \text{rels}_H P H$, we have $x \in \ker(\text{lift}(\text{schreier\_val} P H))$ by definition.
        have hx_ker : x ∈ MonoidHom.ker (FreeGroup.lift (schreier_val P H)) := by
          have hx_ker : x ∈ Subgroup.normalClosure (rels_H P H) := by
            exact Subgroup.subset_normalClosure hx;
          exact H_ker_le P H hx_ker;
        exact hx_ker;
      · exact?

/-
The extended relations `rels_H_extended` are contained in the kernel of the Schreier evaluation map.
-/
def rels_H_extended {G : Type*} [Group G] {ι : Type*} (P : Presentation G ι) (H : Subgroup G) : Set (FreeGroup (@SchreierIndexRight G _ ι H)) :=
  rels_H P H ∪ (Set.range (fun k : RightCosets H ↦ (rewrite P H (Quotient.mk _ 1) (U P H k) : FreeGroup (@SchreierIndexRight G _ ι H))))

theorem rels_H_extended_le_ker {G : Type*} [Group G] {ι : Type*} (P : Presentation G ι) (H : Subgroup G) :
    Subgroup.normalClosure (rels_H_extended P H) ≤ MonoidHom.ker (FreeGroup.lift (schreier_val P H)) := by
      apply Subgroup.normalClosure_le_normal
      intro w hw;
      cases hw;
      · -- Apply the fact that the normal closure of `rels_H` is contained in the kernel of the Schreier evaluation map.
        have h_normal_closure : Subgroup.normalClosure (rels_H P H) ≤ MonoidHom.ker (FreeGroup.lift (schreier_val P H)) := by
          exact?;
        exact h_normal_closure ( Subgroup.subset_normalClosure ‹_› );
      · aesop;
        exact?

/-
Rewriting a generator gives the corresponding Schreier generator.
-/
theorem rewrite_of {G : Type*} [Group G] {ι : Type*} (P : Presentation G ι) (H : Subgroup G) (k : RightCosets H) (s : ι) :
    rewrite P H k (FreeGroup.of s) = FreeGroup.of (k, s) := by
      aesop

/-
A version of `rewrite` with the return type explicitly cast to `FreeGroup (SchreierIndexRight H)` to avoid type mismatches.
-/
def rewrite' {G : Type*} [Group G] {ι : Type*} (P : Presentation G ι) (H : Subgroup G)
    (k : RightCosets H) (w : FreeGroup ι) : FreeGroup (@SchreierIndexRight G _ ι H) :=
  rewrite P H k w

/-
For a generator `(k, s)`, the rewriting of its image under `sigma` is equal to the generator modulo the extended relations.
-/
theorem rewrite_sigma_gen_in_normalClosure {G : Type*} [Group G] {ι : Type*} (P : Presentation G ι) (H : Subgroup G) (k : RightCosets H) (s : ι) :
    let gen := (FreeGroup.of (k, s) : FreeGroup (SchreierIndexRight H))
    rewrite' P H (Quotient.mk (QuotientGroup.rightRel H) 1) (sigma P H gen) * gen⁻¹ ∈ Subgroup.normalClosure (rels_H_extended P H) := by
      bound;
      -- Let `1` denote `Quotient.mk (QuotientGroup.rightRel H) 1`.
      set one : RightCosets H := Quotient.mk _ 1;
      -- Using `rewrite_mul` repeatedly:
      have h_rewrite : rewrite' P H one (sigma P H gen) = rewrite' P H one (U P H k) * rewrite' P H k (FreeGroup.of s) * rewrite' P H (k.act (P.val s)) (U P H (k.act (P.val s)))⁻¹ := by
        have h_rewrite : rewrite' P H one ((sigma P H) gen) = rewrite' P H one (U P H k * FreeGroup.of s * (U P H (k.act (P.val s)))⁻¹) := by
          unfold sigma; aesop;
        have h_rewrite : rewrite' P H one (U P H k * FreeGroup.of s * (U P H (k.act (P.val s)))⁻¹) = rewrite' P H one (U P H k) * rewrite' P H (one.act (FreeGroup.lift P.val (U P H k))) (FreeGroup.of s * (U P H (k.act (P.val s)))⁻¹) := by
          convert rewrite_mul P H one ( U P H k ) ( FreeGroup.of s * ( U P H ( k.act ( P.val s ) ) ) ⁻¹ ) using 1;
          simp +decide only [mul_assoc];
          rfl;
        have h_rewrite : one.act (FreeGroup.lift P.val (U P H k)) = k := by
          have h_rewrite : FreeGroup.lift P.val (U P H k) = τ_right H k := by
            exact coset_word_spec P H k;
          aesop;
          convert τ_right_spec H k;
          ext; simp [RightCosets.act];
        have h_rewrite : rewrite' P H k (FreeGroup.of s * (U P H (k.act (P.val s)))⁻¹) = rewrite' P H k (FreeGroup.of s) * rewrite' P H (k.act (P.val s)) (U P H (k.act (P.val s)))⁻¹ := by
          convert rewrite_mul P H k ( FreeGroup.of s ) ( U P H ( k.act ( P.val s ) ) ) ⁻¹ using 1;
          simp +zetaDelta at *;
          rfl;
        simp_all +decide [ mul_assoc ];
      -- By `rewrite_of`, `rewrite k (of s) = of (k, s)`.
      have h_rewrite_of : rewrite' P H k (FreeGroup.of s) = gen := by
        exact?;
      -- By `rewrite_inv`, `rewrite (k.act (P.val s)) (U (k.act s))⁻¹ = (rewrite 1 (U (k.act s)))⁻¹`.
      have h_rewrite_inv : rewrite' P H (k.act (P.val s)) (U P H (k.act (P.val s)))⁻¹ = (rewrite' P H one (U P H (k.act (P.val s))))⁻¹ := by
        convert rewrite_inv P H one ( U P H ( k.act ( P.val s ) ) ) using 1;
        erw [ coset_word_spec ];
        unfold τ_right; aesop;
        · unfold RightCosets.act; aesop;
        · unfold RightCosets.act; aesop;
      -- Since the normal closure is normal, it's closed under conjugation. Therefore, the product of these two elements is in the normal closure.
      have h_conj : rewrite' P H one (U P H k) ∈ Subgroup.normalClosure (rels_H_extended P H) ∧ (rewrite' P H one (U P H (k.act (P.val s))))⁻¹ ∈ Subgroup.normalClosure (rels_H_extended P H) := by
        simp +zetaDelta at *;
        exact ⟨ Subgroup.subset_normalClosure ( Set.mem_union_right _ ( Set.mem_range_self _ ) ), Subgroup.subset_normalClosure ( Set.mem_union_right _ ( Set.mem_range_self _ ) ) ⟩;
      simp_all +decide [ mul_assoc ];
      exact Subgroup.mul_mem _ h_conj.1 ( Subgroup.Normal.mem_comm inferInstance ( by aesop ) )

/-
The rewriting of the section of a word is equal to the word modulo the extended relations.
-/
theorem rewrite_sigma_eq_extended {G : Type*} [Group G] {ι : Type*} (P : Presentation G ι) (H : Subgroup G) (w : FreeGroup (@SchreierIndexRight G _ ι H)) :
    rewrite' P H (Quotient.mk (QuotientGroup.rightRel H) 1) (sigma P H w) * w⁻¹ ∈ Subgroup.normalClosure (rels_H_extended P H) := by
      revert w;
      -- We proceed by induction on $w$.
      intro w
      induction' w using FreeGroup.induction_on with w hw;
      · exact Subgroup.one_mem _;
      · exact rewrite_sigma_gen_in_normalClosure P H _ _;
      · -- Apply the rewrite_inv lemma to rewrite the expression.
        have h_rewrite_inv : rewrite' P H ⟦1⟧ (sigma P H (FreeGroup.of hw)⁻¹) = (rewrite' P H ⟦1⟧ (sigma P H (FreeGroup.of hw)))⁻¹ := by
          convert rewrite_inv P H _ _ using 2;
          · have := sigma_lift_eq P H ( FreeGroup.of hw );
            unfold RightCosets.act; aesop;
            -- Since $H$ is a subgroup, multiplying by an element of $H$ does not change the coset.
            have h_coset : ∀ h : H, (Quotient.mk (QuotientGroup.rightRel H) 1 : RightCosets H) = (Quotient.mk (QuotientGroup.rightRel H) h : RightCosets H) := by
              aesop;
              simp +decide [ QuotientGroup.rightRel_apply, property ];
            exact h_coset _;
          · bound;
        have := Subgroup.inv_mem _ ‹_›;
        simp_all +decide [ mul_assoc, inv_mul_eq_iff_eq_mul ];
        convert Subgroup.normalClosure_normal.conj_mem _ this ( FreeGroup.of hw ) ⁻¹ using 1 ; group;
      · rename_i x y hx hy;
        -- Using the properties of the rewrite function and the normal closure, we can rewrite the expression.
        have h_rewrite : rewrite' P H (Quotient.mk (QuotientGroup.rightRel H) 1) (sigma P H (x * y)) = rewrite' P H (Quotient.mk (QuotientGroup.rightRel H) 1) (sigma P H x) * rewrite' P H (Quotient.mk (QuotientGroup.rightRel H) 1) (sigma P H y) := by
          convert rewrite_mul P H ( Quotient.mk ( QuotientGroup.rightRel H ) 1 ) ( sigma P H x ) ( sigma P H y ) using 1;
          · simp +decide [ sigma ];
            rfl;
          · congr! 2;
            simp +decide [ sigma_lift_eq ];
            erw [ Quotient.eq ];
            simp +decide [ QuotientGroup.rightRel_apply ];
        -- Using the properties of the normal closure, we can rewrite the expression.
        have h_rewrite : rewrite' P H (Quotient.mk (QuotientGroup.rightRel H) 1) (sigma P H x) * rewrite' P H (Quotient.mk (QuotientGroup.rightRel H) 1) (sigma P H y) * (x * y)⁻¹ = (rewrite' P H (Quotient.mk (QuotientGroup.rightRel H) 1) (sigma P H x) * x⁻¹) * (x * (rewrite' P H (Quotient.mk (QuotientGroup.rightRel H) 1) (sigma P H y) * y⁻¹) * x⁻¹) := by
          group;
        aesop;
        exact Subgroup.mul_mem _ hx ( Subgroup.Normal.mem_comm inferInstance ( by simpa using hy ) )

/-
The kernel of the Schreier evaluation map is contained in the normal closure of the extended relations.
-/
theorem ker_le_rels_H_extended {G : Type*} [Group G] {ι : Type*} (P : Presentation G ι) (H : Subgroup G) :
    MonoidHom.ker (FreeGroup.lift (schreier_val P H)) ≤ Subgroup.normalClosure (rels_H_extended P H) := by
      intro w hw
      obtain ⟨n1, n2, hn1, hn2, hw_eq⟩ : ∃ n1 n2 : FreeGroup (SchreierIndexRight H), n1 ∈ Subgroup.normalClosure (rels_H_extended P H) ∧ n2 ∈ Subgroup.normalClosure (rels_H_extended P H) ∧ w⁻¹ = n1⁻¹ * n2 := by
        obtain ⟨n1, hn1⟩ : ∃ n1 : FreeGroup (SchreierIndexRight H), n1 ∈ Subgroup.normalClosure (rels_H_extended P H) ∧ rewrite' P H (Quotient.mk (QuotientGroup.rightRel H) 1) (sigma P H w) = n1 := by
          have h_sigma_w : FreeGroup.lift P.val (sigma P H w) = 1 := by
            rw [ sigma_lift_eq ];
            aesop;
          have h_sigma_w : sigma P H w ∈ Subgroup.normalClosure P.rels := by
            rw [ ← P.ker_eq ] at * ; aesop;
          have h_rewrite_sigma_w : rewrite' P H (Quotient.mk (QuotientGroup.rightRel H) 1) (sigma P H w) ∈ Subgroup.normalClosure (rels_H P H) := by
            apply rewrite_mem_normalClosure_strong P H (sigma P H w) h_sigma_w;
          exact ⟨ _, Subgroup.normalClosure_mono ( Set.subset_union_left ) h_rewrite_sigma_w, rfl ⟩;
        have := rewrite_sigma_eq_extended P H w;
        exact ⟨ n1, n1 * w⁻¹, hn1.1, by simpa [ hn1.2 ] using this, by group ⟩;
      rw [ inv_eq_iff_eq_inv ] at hw_eq ; aesop

/-
The kernel of the Schreier evaluation map is exactly the normal closure of the extended relations.
-/
theorem H_ker_eq_extended {G : Type*} [Group G] {ι : Type*} (P : Presentation G ι) (H : Subgroup G) :
    MonoidHom.ker (FreeGroup.lift (schreier_val P H)) = Subgroup.normalClosure (rels_H_extended P H) := by
      exact le_antisymm ( ker_le_rels_H_extended P H ) ( rels_H_extended_le_ker P H )

/-
The Schreier presentation of the subgroup H.
-/
def schreierPresentation {G : Type*} [Group G] {ι : Type*} (P : Presentation G ι) (H : Subgroup G) : Presentation H (@SchreierIndexRight G _ ι H) :=
  { val := schreier_val P H
    gen := H_generators_gen P H
    rels := rels_H_extended P H
    ker_eq := H_ker_eq_extended P H }

/-
The set of right cosets is in bijection with the set of left cosets via inversion, so it is finite if the subgroup has finite index.
-/
noncomputable def rightCosetsEquivLeftCosets {G : Type*} [Group G] (H : Subgroup G) : RightCosets H ≃ G ⧸ H :=
  Equiv.mk
    (fun k ↦ k.liftOn (fun g ↦ QuotientGroup.mk (g⁻¹)) (by
    -- If $a$ and $b$ are equivalent under the equivalence relation $a \cdot h = b$, then there exists some $h \in H$ such that $a \cdot h = b$.
    intro a b hab
    obtain ⟨h, hh⟩ := hab;
    aesop))
    (fun q ↦ q.liftOn (fun g ↦ Quotient.mk _ (g⁻¹)) (by
    -- If $aH = bH$, then there exists $h \in H$ such that $a = bh$. Taking inverses, we get $a^{-1} = h^{-1}b^{-1}$.
    intros a b hab
    obtain ⟨h, hh⟩ : ∃ h ∈ H, a = b * h := by
      cases hab ; aesop;
    -- Since $h \in H$, we have $h^{-1} \in H$, and thus $h^{-1}b^{-1} \in b^{-1}H$.
    have h_inv : h⁻¹ ∈ H := by
      exact H.inv_mem hh.1;
    simp +zetaDelta at *;
    rw [ Quotient.eq ];
    simp +decide [ QuotientGroup.rightRel_apply, hh.2, h_inv ]))
    (by
    intro q; induction q using Quotient.inductionOn' ; aesop;)
    (by
    intro q; induction q using Quotient.inductionOn' ; aesop;)

noncomputable instance RightCosets_finite {G : Type*} [Group G] (H : Subgroup G) [H.FiniteIndex] : Finite (RightCosets H) :=
  Finite.of_equiv _ (rightCosetsEquivLeftCosets H).symm

noncomputable instance RightCosets_fintype {G : Type*} [Group G] (H : Subgroup G) [H.FiniteIndex] : Fintype (RightCosets H) :=
  Fintype.ofFinite (RightCosets H)

/-
The set of extended relations is finite if the original relations are finite and the subgroup has finite index.
-/
theorem rels_H_extended_finite {G : Type*} [Group G] {ι : Type*} [Fintype ι] (P : Presentation G ι) (H : Subgroup G) [H.FiniteIndex] (h_fin : Set.Finite P.rels) :
    Set.Finite (rels_H_extended P H) := by
      apply_rules [ Set.Finite.union, h_fin ];
      · have h_finite_rewrite : ∀ k : RightCosets H, Set.Finite (rewrite P H k '' P.rels) := by
          exact fun k => h_fin.image _;
        exact Set.finite_iUnion h_finite_rewrite;
      · apply Set.Finite.subset ( Set.toFinite ( Set.range fun p : RightCosets H × ι => FreeGroup.of p ) );
        exact fun x hx => by obtain ⟨ k, s, h, rfl ⟩ := hx; exact ⟨ ( k, s ), rfl ⟩ ;
      · exact Set.toFinite _

/-
Transfer a presentation along an equivalence of index sets.
-/
def presentationEquiv {G : Type*} [Group G] {ι κ : Type*} (P : Presentation G ι) (e : ι ≃ κ) : Presentation G κ :=
  { val := P.val ∘ e.symm
    gen := by
      convert P.gen using 1;
      simp +decide [ Set.range_comp, Subgroup.closure ]
    rels := (FreeGroup.freeGroupCongr e) '' P.rels
    ker_eq := by
      have h_ker : (FreeGroup.lift (P.val ∘ e.symm)).ker = Subgroup.normalClosure ((FreeGroup.lift P.val).ker.map (FreeGroup.freeGroupCongr e).toMonoidHom) := by
        have h_ker : (FreeGroup.lift (P.val ∘ e.symm)).ker = (FreeGroup.lift P.val).ker.map (FreeGroup.freeGroupCongr e).toMonoidHom := by
          rw [ Subgroup.ext_iff ];
          simp +decide [ MonoidHom.mem_ker, Function.comp ];
          intro x;
          refine' ⟨ fun hx => ⟨ FreeGroup.map e.symm x, _, _ ⟩, fun ⟨ y, hy, hy' ⟩ => _ ⟩;
          · convert hx using 1;
            refine' FreeGroup.induction_on x _ _ _ _ <;> aesop;
          · simp +decide [ FreeGroup.map ];
            induction x using Quot.inductionOn ; aesop;
            exact congr_arg FreeGroup.mk ( List.ext_get ( by simp +decide ) ( by simp +decide [ Function.comp ] ) );
          · rw [ ← hy', ← hy ];
            refine' FreeGroup.induction_on y _ _ _ _ <;> aesop;
        refine' le_antisymm _ _;
        · exact h_ker ▸ Subgroup.le_normalClosure;
        · refine' Subgroup.normalClosure_le_normal _;
          aesop;
      rw [ h_ker, P.ker_eq ];
      refine' le_antisymm _ _;
      · refine' Subgroup.normalClosure_le_normal _;
        simp +decide [ Subgroup.map, Subgroup.normalClosure ];
        simp +decide [ Set.subset_def, Group.conjugatesOfSet ];
        refine' fun x hx => Subgroup.closure_induction ( fun y hy => _ ) _ _ _ hx;
        · simp +decide [ conjugatesOf ] at hy ⊢;
          rcases hy with ⟨ i, hi, c, rfl ⟩ ; exact Subgroup.subset_closure ( Set.mem_iUnion₂.mpr ⟨ i, hi, ⟨ FreeGroup.map e c, by simp +decide ⟩ ⟩ ) ;
        · simp +decide [ Subgroup.one_mem ];
        · exact fun x y hx hy hx' hy' => by simpa using Subgroup.mul_mem _ hx' hy';
        · exact fun x hx₁ hx₂ => by simpa using Subgroup.inv_mem _ hx₂;
      · refine' Subgroup.normalClosure_mono _;
        exact Set.image_subset_iff.mpr fun x hx => Subgroup.mem_map_of_mem _ ( Subgroup.subset_normalClosure hx ) }

/-
Transferring a presentation along an equivalence of index sets preserves finiteness of relations.
-/
theorem presentationEquiv_finite {G : Type*} [Group G] {ι κ : Type*} (P : Presentation G ι) (e : ι ≃ κ) (h : Set.Finite P.rels) :
    Set.Finite (presentationEquiv P e).rels := by
      exact h.image _

#print isFinitelyPresented'

/-
The index set for the Schreier presentation is finite.
-/
noncomputable instance SchreierIndexRight_fintype {G : Type*} [Group G] {ι : Type*} [Fintype ι] (H : Subgroup G) [H.FiniteIndex] : Fintype (@SchreierIndexRight G _ ι H) :=
  inferInstanceAs (Fintype (RightCosets H × ι))

/-
Construct a finite presentation for a finite index subgroup from a finite presentation of the group.
-/
noncomputable def schreierFinitePresentation {G : Type*} [Group G] {ι : Type*} [Fintype ι] (P : FinitePresentation G ι) (H : Subgroup G) [H.FiniteIndex] : FinitePresentation H (@SchreierIndexRight G _ ι H) :=
  let P_pres := expe G ι P
  let rels_set := rels_H_extended P_pres H
  have h_fin : Set.Finite rels_set := rels_H_extended_finite P_pres H (Finset.finite_toSet P.rels)
  { val := schreier_val P_pres H
    gen := H_generators_gen P_pres H
    rels := h_fin.toFinset
    ker_eq := by
      convert H_ker_eq_extended P_pres H using 1
      generalize_proofs at *;
      rw [ Set.Finite.coe_toFinset ] }

/-
If a group has a finite presentation, it satisfies the `isFinitelyPresented'` predicate.
-/
lemma isFinitelyPresented'_of_FinitePresentation {G : Type*} [Group G] {ι : Type*} [Fintype ι] (P : FinitePresentation G ι) : isFinitelyPresented' G := by
  constructor;
  refine' ⟨ _, _, _ ⟩;
  rotate_right;
  exact ULift ( Fin ( Fintype.card ι ) );
  exact inferInstance;
  exact presentationEquiv ( expe G ι P ) ( Fintype.equivOfCardEq ( by simp +decide ) );
  exact Set.Finite.to_subtype ( presentationEquiv_finite ( expe G ι P ) ( Fintype.equivOfCardEq ( by simp +decide ) ) ( Finset.finite_toSet P.rels ) )

/-
Proof of the Reidemeister-Schreier theorem.
-/
theorem ReidemeisterSchreierStatement_proof : ReidemeisterSchreierStatement := by
  intro G H;
  rintro H _ ⟨ ι, _, P, hP ⟩;
  -- Let's choose any finite presentation of G and derive a finite presentation of H.
  obtain ⟨P, hP⟩ : ∃ (P : FinitePresentation G ι), True := by
    refine' ⟨ _, trivial ⟩;
    constructor;
    convert P.ker_eq;
    swap;
    exact Set.Finite.toFinset hP;
    aesop;
  convert isFinitelyPresented'_of_FinitePresentation ( schreierFinitePresentation P H )

/-
If a group has a finite presentation, it satisfies the `isFinitelyPresented'` predicate.
-/
lemma isFinitelyPresented'_of_FinitePresentation_renamed {G : Type u} [Group G] {ι : Type v} [Fintype ι] (P : FinitePresentation G ι) : isFinitelyPresented'.{u, v} G := by
  exact?

/-
If a group has a finite presentation, it satisfies the `isFinitelyPresented'` predicate.
-/
lemma isFinitelyPresented'_of_FinitePresentation_correct {G : Type*} [Group G] {ι : Type*} [Fintype ι] (P : FinitePresentation G ι) : isFinitelyPresented' G := by
  exact?

/-
Proof of the Reidemeister-Schreier theorem.
-/
theorem ReidemeisterSchreierStatement_proven : ReidemeisterSchreierStatement := by
  intro G _ H _ hG
  obtain ⟨ι, hι, P, hP⟩ := hG
  -- Construct FinitePresentation from P
  let P_fin : FinitePresentation G ι :=
    { val := P.val
      gen := P.gen
      rels := Set.Finite.toFinset hP
      ker_eq := by
        rw [Set.Finite.coe_toFinset]
        exact P.ker_eq }
  -- Get Schreier presentation
  let P_H := schreierFinitePresentation P_fin H
  -- Use the lemma to show H is finitely presented
  exact isFinitelyPresented'_of_FinitePresentation P_H